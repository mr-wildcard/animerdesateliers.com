"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLPlugin = void 0;
const vscode_emmet_helper_1 = require("vscode-emmet-helper");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const vscode_languageserver_1 = require("vscode-languageserver");
const utils_1 = require("../../core/documents/utils");
class HTMLPlugin {
    constructor(docManager, configManager) {
        this.lang = vscode_html_languageservice_1.getLanguageService();
        this.documents = new WeakMap();
        this.styleScriptTemplate = new Set(['template', 'style', 'script']);
        this.pluginName = 'HTML';
        docManager.on('documentChange', (document) => {
            this.documents.set(document, document.html);
        });
        this.configManager = configManager;
    }
    getCompletions(document, position) {
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideFrontmatter(document, position) || this.isInsideExpression(html, document, position)) {
            return null;
        }
        const offset = document.offsetAt(position);
        const node = html.findNodeAt(offset);
        if (this.isComponentTag(node)) {
            return null;
        }
        const emmetResults = {
            isIncomplete: true,
            items: [],
        };
        this.lang.setCompletionParticipants([vscode_emmet_helper_1.getEmmetCompletionParticipants(document, position, 'html', this.configManager.getEmmetConfig(), emmetResults)]);
        const results = this.lang.doComplete(document, position, html);
        const items = this.toCompletionItems(results.items);
        return vscode_languageserver_1.CompletionList.create([...this.toCompletionItems(items), ...this.getLangCompletions(items), ...emmetResults.items], 
        // Emmet completions change on every keystroke, so they are never complete
        emmetResults.items.length > 0);
    }
    getFoldingRanges(document) {
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        return this.lang.getFoldingRanges(document);
    }
    doTagComplete(document, position) {
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideFrontmatter(document, position) || this.isInsideExpression(html, document, position)) {
            return null;
        }
        return this.lang.doTagComplete(document, position, html);
    }
    /**
     * The HTML language service uses newer types which clash
     * without the stable ones. Transform to the stable types.
     */
    toCompletionItems(items) {
        return items.map((item) => {
            if (!item.textEdit || vscode_languageserver_1.TextEdit.is(item.textEdit)) {
                return item;
            }
            return {
                ...item,
                textEdit: vscode_languageserver_1.TextEdit.replace(item.textEdit.replace, item.textEdit.newText),
            };
        });
    }
    getLangCompletions(completions) {
        const styleScriptTemplateCompletions = completions.filter((completion) => completion.kind === vscode_languageserver_1.CompletionItemKind.Property && this.styleScriptTemplate.has(completion.label));
        const langCompletions = [];
        addLangCompletion('style', ['scss', 'sass']);
        return langCompletions;
        /** Add language completions */
        function addLangCompletion(tag, languages) {
            const existingCompletion = styleScriptTemplateCompletions.find((completion) => completion.label === tag);
            if (!existingCompletion) {
                return;
            }
            languages.forEach((lang) => langCompletions.push({
                ...existingCompletion,
                label: `${tag} (lang="${lang}")`,
                insertText: existingCompletion.insertText && `${existingCompletion.insertText} lang="${lang}"`,
                textEdit: existingCompletion.textEdit && vscode_languageserver_1.TextEdit.is(existingCompletion.textEdit)
                    ? {
                        range: existingCompletion.textEdit.range,
                        newText: `${existingCompletion.textEdit.newText} lang="${lang}"`,
                    }
                    : undefined,
            }));
        }
    }
    isInsideExpression(html, document, position) {
        const offset = document.offsetAt(position);
        const node = html.findNodeAt(offset);
        return utils_1.isInsideExpression(document.getText(), node.start, offset);
    }
    isInsideFrontmatter(document, position) {
        return utils_1.isInsideFrontmatter(document.getText(), document.offsetAt(position));
    }
    isComponentTag(node) {
        if (!node.tag) {
            return false;
        }
        const firstChar = node.tag[0];
        return /[A-Z]/.test(firstChar);
    }
}
exports.HTMLPlugin = HTMLPlugin;
